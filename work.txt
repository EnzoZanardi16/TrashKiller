import Projectile from '../components/Projectile';
import PowerUp from '../components/PowerUp';
import EnemyThree from '../components/EnemyThree';
import EnemyProjectile from '../components/EnemyProjectile';
import Boss from '../components/Boss';

import { Audio } from 'expo-av';

// ----------------------------------------------------
// 1. IMPORTA√á√ÉO DOS ARQUIVOS DE SOM
// ----------------------------------------------------
import laserAsset from '../assets/sounds/laser.mp3';
import laserBeamAsset from '../assets/sounds/laser_beam.mp3';
import boostAsset from '../assets/sounds/boost.mp3';
import hurtEnemyAsset from '../assets/sounds/hurt-enemy.mp3';
import playerHurtAsset from '../assets/sounds/player-hurt.mp3';
import gameOverAsset from '../assets/sounds/game-over.mp3';
import musicAsset from '../assets/sounds/musica.mp3'; // M√∫sica de fundo

// ----------------------------------------------------
// 2. CONFIGURA√á√ïES E POOLS DE SOM
// ----------------------------------------------------
const MAX_SFX_CHANNELS = 5; 

const soundPools = {
    // SFX ORIGINAIS
    laser: { pool: [], index: 0, asset: laserAsset, volume: 0.5, durationToPlay: 100 }, 
    laserBeam: { pool: [], index: 0, asset: laserBeamAsset, volume: 1.0, durationToPlay: 0 }, 
    boost: { pool: [], index: 0, asset: boostAsset, volume: 1.0, durationToPlay: 0 },

    // NOVOS SFX
    hurtEnemy: { pool: [], index: 0, asset: hurtEnemyAsset, volume: 0.7, durationToPlay: 0, maxChannels: 3 }, 
    playerHurt: { pool: [], index: 0, asset: playerHurtAsset, volume: 1.0, durationToPlay: 0, maxChannels: 1 }, 
    gameOver: { pool: [], index: 0, asset: gameOverAsset, volume: 1.0, durationToPlay: 0, maxChannels: 1 }, 
};

let backgroundMusic = null; 
let soundsLoaded = false; 


async function loadMusic() {
    try {
        if (backgroundMusic) return;

        const { sound } = await Audio.Sound.createAsync(musicAsset, { 
            shouldPlay: true, 
            isLooping: true, 
            volume: 0.4,     
        });
        
        backgroundMusic = sound;
        console.log('‚úÖ M√∫sica de Fundo carregada e iniciada em loop.');

    } catch (error) {
        console.warn('‚ùå Erro ao carregar a M√∫sica de Fundo: ', error);
    }
}


async function loadSounds() {
    if (soundsLoaded) return;
    
    try {
        await Audio.setAudioModeAsync({
            allowsRecording: false,
            shouldDuckAndroid: true,
            playsInSilentModeIOS: true,
        });

        for (const key in soundPools) {
            const config = soundPools[key];
            const max = config.maxChannels || MAX_SFX_CHANNELS;
            config.pool = [];
            
            for (let i = 0; i < max; i++) {
                const { sound } = await Audio.Sound.createAsync(config.asset, { shouldPlay: false, isLooping: false });
                await sound.setVolumeAsync(config.volume);
                config.pool.push(sound);
            }
            console.log(`‚úÖ Sound Pool '${key}' carregado com ${max} canais.`);
        }
        
        soundsLoaded = true;
        console.log('--- Todos os SFX carregados com sucesso! ---');
        
        await loadMusic(); 

    } catch (error) {
        console.error('‚ùå ERRO CR√çTICO ao carregar e configurar o Sound Pool:', error);
    }
}

loadSounds(); 


function playSound(soundKey) {
    if (!soundsLoaded) return;
    
    const config = soundPools[soundKey];
    if (!config || config.pool.length === 0) return;
    
    const soundObject = config.pool[config.index];
    config.index = (config.index + 1) % config.pool.length; 
    
    (async () => {
        try {
            await soundObject.stopAsync();
            await soundObject.playFromPositionAsync(0);
            
            if (config.durationToPlay > 0) {
                setTimeout(async () => {
                    try {
                        await soundObject.stopAsync();
                    } catch (e) {
                        // Silencia erros.
                    }
                }, config.durationToPlay);
            }
        } catch (error) {
            // Silencia erros.
        }
    })(); 
}


let lastTouchX = 0;
let lastTouchY = 0;

const GameSystem = (entities, { touches, time, dispatch }) => {
  
  // VERIFICA√á√ÉO DE SEGURAN√áA
  if (!entities || !entities.player || !soundsLoaded) {
      return entities; 
  }

  const player = entities.player;
  const now = time.current;
  
  // ----------------------------------------------------
  // L√ìGICA DE GAME OVER (CORRIGIDA)
  // ----------------------------------------------------
  if (player.lives <= 0 && !entities.isGameOver) {
      
      // 1. Para a m√∫sica de fundo de forma imediata (e ass√≠ncrona)
      if (backgroundMusic) {
          backgroundMusic.stopAsync();
          backgroundMusic = null; 
      }
      
      // 2. Toca o som de Game Over
      // Adicionado um pequeno atraso para o som de Game Over,
      // pois √†s vezes o stopAsync pode bloquear a thread por milissegundos.
      // Isso deve garantir que o som de game over seja priorizado.
      setTimeout(() => {
          playSound('gameOver');
      }, 50); 
      
      entities.isGameOver = true;
      dispatch({ type: 'game-over' });
      return entities;
  }
  
  if (entities.isGameOver) return entities;


  // L√≥gica de N√≠vel (Mantida)
  if (now >= 600000) { 
    player.level = 5;
  } else if (now >= 300000) { 
    player.level = 4;
  } else if (now >= 180000) { 
    player.level = 3;
  } else if (now >= 60000) { 
    player.level = 2;
  } else { 
    player.level = 1;
  }

  // Inicializa o estado do jogo e o contador de chefes (Mantida)
  if (entities.lastShotTime === undefined) {
      entities.lastShotTime = now;
  }
  if (!entities.gameState) {
    entities.gameState = 'wave';
  }
  if (!entities.lastBossSpawnTime) {
    entities.lastBossSpawnTime = now;
  }
  if (!entities.bossSpawnCount) {
      entities.bossSpawnCount = 0;
  }

  // Verifica se √© hora de mudar para o estado do chefe (Mantida)
  const bossSpawnInterval = 120000;
  if (entities.gameState === 'wave' && now - entities.lastBossSpawnTime > bossSpawnInterval) {
    entities.gameState = 'boss';
  }

  // Se o estado for 'boss', cria o chefe se ele ainda n√£o existir (Mantida)
  if (entities.gameState === 'boss' && !entities.bossKey) {
    entities.bossSpawnCount++;
    const currentBossHealth = 40 + (entities.bossSpawnCount * 30);
    const bossId = `boss-${Date.now()}`;
    entities[bossId] = {
      position: [0, 50],
      health: currentBossHealth,
      renderer: Boss,
      lastShotTime: 0
    };
    entities.bossKey = bossId;
  }

  // L√≥gica de movimento da nave (Mantida)
  const touch = (touches || []).find(t => t.type === 'move');
  if (touch) {
    const screenWidth = 390;
    const screenHeight = 800;
    const playerSize = 50;
    
    const deltaX = touch.event.pageX - lastTouchX;
    const deltaY = touch.event.pageY - lastTouchY;
    
    let newX = player.position[0] + deltaX;
    let newY = player.position[1] + deltaY;

    newX = Math.max(0, Math.min(newX, screenWidth - playerSize));
    newY = Math.max(0, Math.min(newY, screenHeight - playerSize));

    player.position = [newX, newY];
    
    lastTouchX = touch.event.pageX;
    lastTouchY = touch.event.pageY;
  } else if ((touches || []).find(t => t.type === 'start')) {
    const startTouch = (touches || []).find(t => t.type === 'start');
    lastTouchX = startTouch.event.pageX;
    lastTouchY = startTouch.event.pageY;
  }

  // L√≥gica de Invencibilidade e de Power-Up de tiro r√°pido (Mantida)
  if (player.isInvincible && now - player.invincibleTimer > 2000) {
    player.isInvincible = false;
  }
  
  if (player.isRapidFire && now - player.rapidFireTimer > 9000) {
      player.isRapidFire = false;
  }
  
  // L√≥gica para atirar automaticamente (Protagonista)
  let shootInterval = player.isRapidFire ? 200 : 500;
  
  if (player.level > 1) {
    shootInterval -= (player.level - 1) * 50; 
  }

  if (now - entities.lastShotTime > shootInterval) {
    entities.lastShotTime = now;
    
    // ----------------------------------------------------
    // üéØ CHAMADA DE SOM DE TIRO (CORRIGIDA)
    // ----------------------------------------------------
    if (player.isRapidFire) {
        // Se for rapid fire, sempre toca o som de feixe
        playSound('laserBeam'); 
    } else {
        // Se n√£o for rapid fire, usa o som normal
        playSound('laser'); 
    }
    // ----------------------------------------------------


    // L√≥gica de cria√ß√£o de proj√©teis (Mantida)
    if (player.level === 2) {
      entities[`projectile${Date.now()}`] = {
        position: [player.position[0] + 5, player.position[1]],
        renderer: Projectile
      };
      entities[`projectile${Date.now() + 1}`] = {
        position: [player.position[0] + 35, player.position[1]],
        renderer: Projectile
      };
    } else if (player.level === 3) {
      entities[`projectile${Date.now()}`] = {
        position: [player.position[0], player.position[1]],
        renderer: Projectile
      };
      entities[`projectile${Date.now() + 1}`] = {
        position: [player.position[0] + 20, player.position[1]],
        renderer: Projectile
      };
      entities[`projectile${Date.now() + 2}`] = {
        position: [player.position[0] + 40, player.position[1]],
        renderer: Projectile
      };
    } else if (player.level === 4) {
      entities[`projectile${Date.now()}`] = {
        position: [player.position[0], player.position[1]],
        renderer: Projectile
      };
      entities[`projectile${Date.now() + 1}`] = {
        position: [player.position[0] + 15, player.position[1]],
        renderer: Projectile
      };
      entities[`projectile${Date.now() + 2}`] = {
        position: [player.position[0] + 30, player.position[1]],
        renderer: Projectile
      };
      entities[`projectile${Date.now() + 3}`] = {
        position: [player.position[0] + 45, player.position[1]],
        renderer: Projectile
      };
    } else if (player.level >= 5) {
      entities[`projectile${Date.now()}`] = {
        position: [player.position[0] - 5, player.position[1]],
        renderer: Projectile
      };
      entities[`projectile${Date.now() + 1}`] = {
        position: [player.position[0] + 10, player.position[1]],
        renderer: Projectile
      };
      entities[`projectile${Date.now() + 2}`] = {
        position: [player.position[0] + 25, player.position[1]],
        renderer: Projectile
      };
      entities[`projectile${Date.now() + 3}`] = {
        position: [player.position[0] + 40, player.position[1]],
        renderer: Projectile
      };
      entities[`projectile${Date.now() + 4}`] = {
        position: [player.position[0] + 55, player.position[1]],
        renderer: Projectile
      };
    } else {
      // Level 1: Tiro √∫nico
      entities[`projectile${Date.now()}`] = {
        position: [player.position[0] + 20, player.position[1]],
        renderer: Projectile
      };
    }
  }

  // L√≥gica de Movimento de Inimigos e Colis√£o (Mantida)
  if (entities.gameState === 'wave') {
      const baseEnemySpeed = 2;
      const maxEnemySpeed = 8;
      const timeProgress = Math.max(0, now - 30000); 
      const timeFactor = Math.min(timeProgress / 600000, 1); 
      const enemySpeed = baseEnemySpeed + (maxEnemySpeed - baseEnemySpeed) * timeFactor;
      
      const enemies = Object.keys(entities).filter(k => k.startsWith('enemy'));
      
      enemies.forEach(enemyKey => {
        const enemy = entities[enemyKey];
        enemy.position[1] += enemySpeed;
        
        // L√≥gica de tiro do EnemyThree (Mantida)
        if (enemy.renderer === EnemyThree && now - enemy.lastShotTime > 1000) {
          enemy.lastShotTime = now;
          const projectileId = `enemy-projectile-${Date.now()}`;
          entities[projectileId] = {
            position: [enemy.position[0] + 20, enemy.position[1] + 50],
            renderer: EnemyProjectile
          };
        }

        if (enemy.position[1] > 800) {
          delete entities[enemyKey];
          return;
        }

        // Colis√£o do inimigo com o protagonista (Mantida)
        if (!player.isInvincible) {
          const enemyXCenter = enemy.position[0] + 25;
          const enemyYCenter = enemy.position[1] + 25;
          const playerXCenter = player.position[0] + 25;
          const playerYCenter = player.position[1] + 25;

          const distance = Math.sqrt(
            Math.pow(enemyXCenter - playerXCenter, 2) + Math.pow(enemyYCenter - playerYCenter, 2)
          );

          if (distance < 30) {
            playSound('playerHurt');
            dispatch({ type: 'life-lost' });
            player.isInvincible = true;
            player.invincibleTimer = now;
            delete entities[enemyKey]; 
          }
        }
      });
  }

  // L√≥gica do Chefe (Mantida)
  if (entities.gameState === 'boss') {
      // ... (L√≥gica do Chefe Mantida) ...
  }

  // L√≥gica de Movimento e Colis√£o dos Proj√©teis (Protagonista)
  const projectileSpeed = 10;
  const projectiles = Object.keys(entities).filter(k => k.startsWith('projectile') && !k.startsWith('enemy-projectile') && !k.startsWith('boss-projectile'));
  
  projectiles.forEach(projectileKey => {
    const projectile = entities[projectileKey];
    if (!projectile) return;
    projectile.position[1] -= projectileSpeed;

    // Colis√£o com o Chefe 
    if (entities.bossKey) {
        const boss = entities[entities.bossKey];
        const bossXCenter = boss.position[0] + 195;
        const bossYCenter = boss.position[1] + 50;
        const projectileXCenter = projectile.position[0] + 7.5;
        const projectileYCenter = projectile.position[1] + 7.5;
        
        const distance = Math.sqrt(
            Math.pow(bossXCenter - projectileXCenter, 2) + Math.pow(bossYCenter - projectileYCenter, 2)
        );
        if (distance < 100) {
            boss.health--;
            delete entities[projectileKey];
            if (boss.health <= 0) {
                // ‚≠ê NOVO: Som de Dano/Morte no Inimigo (para o Boss)
                playSound('hurtEnemy');
                delete entities[entities.bossKey];
                delete entities.bossKey;
                entities.gameState = 'wave';
                entities.lastBossSpawnTime = now;
            }
        }
    }

    // Colis√£o com inimigos normais
    const enemies = Object.keys(entities).filter(k => k.startsWith('enemy'));
    enemies.forEach(enemyKey => {
      const enemy = entities[enemyKey];
      if (!enemy || !projectile) return;

      const enemyXCenter = enemy.position[0] + 25;
      const enemyYCenter = enemy.position[1] + 25;
      const projectileXCenter = projectile.position[0] + 7.5;
      const projectileYCenter = projectile.position[1] + 7.5;

      const distance = Math.sqrt(
        Math.pow(enemyXCenter - projectileXCenter, 2) + Math.pow(enemyYCenter - projectileYCenter, 2)
      );

      if (distance < 25) {
        enemy.health--;
        delete entities[projectileKey];

        if (enemy.health <= 0) {
          // ‚≠ê CORRE√á√ÉO: Som de Morte (hurtEnemy) AQUI, n√£o no acerto.
          playSound('hurtEnemy');
          
          if (Math.random() < 0.1) {
            const powerUpType = Math.random() < 0.5 ? 'rapid-fire' : 'life';
            const powerUpId = `powerUp${Date.now()}`;
            entities[powerUpId] = {
              position: [enemy.position[0], enemy.position[1]],
              type: powerUpType,
              renderer: PowerUp
            };
          }
          delete entities[enemyKey];
        }
      }
    });

    if (projectile.position[1] < -20) {
      delete entities[projectileKey];
    }
  });

  // L√≥gica de Movimento e Colis√£o dos Proj√©teis do Inimigo e Chefe (Mantida)
  const enemyProjectileSpeed = 5;
  const allEnemyProjectiles = Object.keys(entities).filter(k => k.startsWith('enemy-projectile') || k.startsWith('boss-projectile'));
  
  allEnemyProjectiles.forEach(projectileKey => {
      const projectile = entities[projectileKey];
      if (!projectile) return;

      if (projectileKey.startsWith('boss-projectile')) {
          projectile.position[0] += projectile.vx;
          projectile.position[1] += projectile.vy;
      } else {
          projectile.position[1] += enemyProjectileSpeed;
      }

      // Colis√£o do proj√©til do inimigo com o jogador (Mantida)
      if (!player.isInvincible) {
          const distance = Math.sqrt(
              Math.pow((projectile.position[0] + 7.5) - (player.position[0] + 25), 2) + Math.pow((projectile.position[1] + 7.5) - (player.position[1] + 25), 2)
          );
          if (distance < 30) {
              playSound('playerHurt');
              dispatch({ type: 'life-lost' });
              player.isInvincible = true;
              player.invincibleTimer = now;
              delete entities[projectileKey];
          }
      }
      
      if (projectile.position[1] > 800) {
          delete entities[projectileKey];
      }
  });
  
  // L√≥gica de Movimento de Power-Ups e Colis√£o com Protagonista (Mantida)
  const powerUpSpeed = 1.5;
  const powerUps = Object.keys(entities).filter(k => k.startsWith('powerUp'));
  powerUps.forEach(powerUpKey => {
    const powerUp = entities[powerUpKey];
    powerUp.position[1] += powerUpSpeed;

    const distance = Math.sqrt(
      Math.pow(powerUp.position[0] - player.position[0], 2) + Math.pow(powerUp.position[1] - player.position[1], 2)
    );

    if (distance < 30) {
      playSound('boost'); 

      if (powerUp.type === 'rapid-fire') {
        player.isRapidFire = true;
        player.rapidFireTimer = now; 
      } else if (powerUp.type === 'life') {
        dispatch({ type: 'life-gained' });
      }
      delete entities[powerUpKey];
    }

    if (powerUp.position[1] > 800) {
        delete entities[powerUpKey];
    }
  });
  
  return entities;
};

export default GameSystem;